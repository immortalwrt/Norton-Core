--- a/libraries/libapparmor/src/private.c
+++ b/libraries/libapparmor/src/private.c
@@ -39,10 +39,20 @@
  #ifdef HAVE___SECURE_GETENV
   #define secure_getenv __secure_getenv
  #else
-  #error neither secure_getenv nor __secure_getenv is available
+/*  we running single user, no big harm to use
+    getenv() instead of secure_getenv().
+    Also uClibc(-ng) do not support  secure version
+*/
+  #define secure_getenv getenv
  #endif
 #endif
 
+#ifndef HAVE_SCANDIRAT
+extern int scandirat(int dirfd, const char *dirp, struct dirent ***namelist,
+      int (*filter)(const struct dirent *),
+      int (*compar)(const struct dirent**, const struct dirent **));
+#endif
+
 struct ignored_suffix_t {
 	const char * text;
 	int len;
--- a/libraries/libapparmor/configure.ac
+++ b/libraries/libapparmor/configure.ac
@@ -3,9 +3,10 @@ m4_ifdef(__apparmor_version, , m4_define
 m4_define([__aalen], decr(len(__apparmor_version)))
 m4_define([apparmor_version], m4_substr(__apparmor_version, 0, __aalen))
 
-AC_INIT(configure.ac)
-
-AM_INIT_AUTOMAKE(libapparmor1, apparmor_version)
+AC_INIT(libapparmor1, apparmor_version)
+AC_CONFIG_SRCDIR(configure.ac)
+AC_CONFIG_MACRO_DIR([m4])
+AM_INIT_AUTOMAKE
 
 AM_PROG_LEX
 AC_PROG_YACC
@@ -81,7 +82,9 @@ AM_CONDITIONAL(HAVE_RUBY, test x$with_ru
 AC_HEADER_STDC
 AC_CHECK_HEADERS(unistd.h stdint.h syslog.h)
 
-AC_CHECK_FUNCS([asprintf __secure_getenv secure_getenv])
+AC_CHECK_FUNCS([asprintf __secure_getenv secure_getenv openat scandirat bindtextdomain])
+AM_CONDITIONAL([SCANDIR_AT], [test x$ac_cv_func_scandirat = xno] )
+AM_CONDITIONAL([ADD_LIBINTL], [test x$ac_cv_func_bindtextdomain = xno])
 
 AM_PROG_CC_C_O
 AC_C_CONST
--- a/libraries/libapparmor/src/Makefile.am
+++ b/libraries/libapparmor/src/Makefile.am
@@ -1,4 +1,4 @@
-INCLUDES = $(all_includes)
+AM_CPPFLAGS = $(all_includes)
 
 # variables to set the library versions used by libtool
 # Step through these rules IN ORDER to update the library version.
@@ -36,13 +36,13 @@
 AM_LFLAGS = -v
 AM_YFLAGS = -d -p aalogparse_
 AM_CFLAGS = -Wall
-AM_CPPFLAGS = -D_GNU_SOURCE -I$(top_srcdir)/include/
+AM_CPPFLAGS += -D_GNU_SOURCE -I$(top_srcdir)/include/
 scanner.h: scanner.l
 	$(LEX) -v $<
 
 scanner.c: scanner.l
 
-af_protos.h: /usr/include/netinet/in.h
+af_protos.h: $(includedir)/netinet/in.h
 	 LC_ALL=C  sed  -n -e "/IPPROTO_MAX/d"  -e "s/^\#define[ \\t]\\+IPPROTO_\\([A-Z0-9_]\\+\\)\\(.*\\)$$/AA_GEN_PROTO_ENT(\\UIPPROTO_\\1, \"\\L\\1\")/p" $< > $@
 
 lib_LTLIBRARIES = libapparmor.la
@@ -52,6 +52,14 @@
 libapparmor_la_LDFLAGS = -version-info $(AA_LIB_CURRENT):$(AA_LIB_REVISION):$(AA_LIB_AGE) -XCClinker -dynamic -pthread \
 	-Wl,--version-script=$(top_srcdir)/src/libapparmor.map
 
+if SCANDIR_AT
+libapparmor_la_SOURCES += scandirat.c
+endif
+
+if ADD_LIBINTL
+libapparmor_la_SOURCES += intl.c
+endif
+
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = libapparmor.pc
 
--- /dev/null
+++ b/libraries/libapparmor/src/scandirat.c
@@ -0,0 +1,123 @@
+// add scandirat()
+// this is  by all reason not an attempt to
+// add this functionality to uClibc
+// it just supply function for apparmor
+// which is not implementded in uClibc
+// Proper way would be  fix apparmor
+// itself. But we are not in this buisnes.
+//
+#include <dirent.h>
+#include <fcntl.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <errno.h>
+#if 0
+#include <features.h>
+#include <sys/types.h>
+#include <bits/uClibc_mutex.h>
+
+/* Directory stream type.  */
+struct __dirstream {
+  int dd_fd;
+  size_t dd_nextloc;
+  size_t dd_size;
+  void *dd_buf;
+  off_t dd_nextoff;
+  size_t dd_max;
+  __UCLIBC_MUTEX(dd_lock);
+};
+#endif
+
+
+# define __SCANDIRAT scandirat
+# define __DIRENT_TYPE struct dirent
+# define __READDIR readdir
+
+
+int __SCANDIRAT(int dfd, const char *dir, __DIRENT_TYPE ***namelist,
+	int (*selector) (const __DIRENT_TYPE *),
+	int (*compar) (const __DIRENT_TYPE **, const __DIRENT_TYPE **))
+{
+    int l_dirfd = openat(dfd, dir, O_RDONLY | O_CLOEXEC | O_DIRECTORY);
+    if(l_dirfd == -1 )
+        return -1;
+
+    DIR *dp = fdopendir (l_dirfd);
+    __DIRENT_TYPE *current;
+    __DIRENT_TYPE **names = NULL;
+    size_t names_size = 0, pos;
+    int save;
+
+    if (dp == NULL)
+	return -1;
+
+    save = errno;
+    errno = 0;
+
+    pos = 0;
+    while ((current = __READDIR (dp)) != NULL) {
+	int use_it = selector == NULL;
+
+	if (! use_it)
+	{
+	    use_it = (*selector) (current);
+	    /* The selector function might have changed errno.
+	     * It was zero before and it need to be again to make
+	     * the latter tests work.  */
+	    if (! use_it)
+		    errno = 0;
+	}
+	if (use_it)
+	{
+	    __DIRENT_TYPE *vnew;
+	    size_t dsize;
+
+	    /* Ignore errors from selector or readdir */
+	    errno = 0;
+
+	    if(pos == names_size)
+	    {
+		__DIRENT_TYPE **new;
+		if (names_size == 0)
+		    names_size = 10;
+		else
+		    names_size *= 2;
+		new = (__DIRENT_TYPE **) realloc (names,
+					names_size * sizeof (__DIRENT_TYPE *));
+		if (new == NULL)
+		    break;
+		names = new;
+	    }
+
+	    dsize = &current->d_name[_D_ALLOC_NAMLEN(current)] - (char*)current;
+	    vnew = (__DIRENT_TYPE *) malloc (dsize);
+	    if (vnew == NULL)
+		break;
+
+	    names[pos++] = (__DIRENT_TYPE *) memcpy (vnew, current, dsize);
+	}
+    }
+
+    if(errno != 0)
+    {
+	save = errno;
+	closedir (dp);
+	while (pos > 0)
+	    free (names[--pos]);
+	free (names);
+	errno = save;
+	return -1;
+    }
+
+    closedir (dp);
+    errno = save;
+
+    /* Sort the list if we have a comparison function to sort with.  */
+    if (compar != NULL)
+	qsort (names, pos, sizeof (__DIRENT_TYPE *), (comparison_fn_t) compar);
+    *namelist = names;
+    return pos;
+}
+
--- /dev/null
+++ b/libraries/libapparmor/include/sys/libintl.h
@@ -0,0 +1,131 @@
+/* Message catalogs for internationalization.
+   Copyright (C) 1995-2002, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   This file is derived from the file libgettext.h in the GNU gettext package.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBINTL_H
+#define _LIBINTL_H	1
+
+/* We define an additional symbol to signal that we use the GNU
+   implementation of gettext.  */
+#define __USE_GNU_GETTEXT 1
+
+/* Provide information about the supported file formats.  Returns the
+   maximum minor revision number supported for a given major revision.  */
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) \
+  ((major) == 0 ? 1 : -1)
+
+__BEGIN_DECLS
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+extern char *gettext (const char *__msgid)
+     __THROW __attribute_format_arg__ (1);
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current
+   LC_MESSAGES locale.  */
+extern char *dgettext (const char *__domainname, const char *__msgid)
+     __THROW __attribute_format_arg__ (2);
+#if 0 /* uClibc: disabled */
+extern char *__dgettext (const char *__domainname, const char *__msgid)
+     __THROW __attribute_format_arg__ (2);
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+extern char *dcgettext (const char *__domainname,
+			const char *__msgid, int __category)
+     __THROW __attribute_format_arg__ (2);
+#if 0 /* uClibc: disabled */
+extern char *__dcgettext (const char *__domainname,
+			  const char *__msgid, int __category)
+     __THROW __attribute_format_arg__ (2);
+#endif
+
+
+/* Similar to `gettext' but select the plural form corresponding to the
+   number N.  */
+extern char *ngettext (const char *__msgid1, const char *__msgid2,
+		       unsigned long int __n)
+     __THROW __attribute_format_arg__ (1) __attribute_format_arg__ (2);
+
+/* Similar to `dgettext' but select the plural form corresponding to the
+   number N.  */
+extern char *dngettext (const char *__domainname, const char *__msgid1,
+			const char *__msgid2, unsigned long int __n)
+     __THROW __attribute_format_arg__ (2) __attribute_format_arg__ (3);
+
+/* Similar to `dcgettext' but select the plural form corresponding to the
+   number N.  */
+extern char *dcngettext (const char *__domainname, const char *__msgid1,
+			 const char *__msgid2, unsigned long int __n,
+			 int __category)
+     __THROW __attribute_format_arg__ (2) __attribute_format_arg__ (3);
+
+
+/* Set the current default message catalog to DOMAINNAME.
+   If DOMAINNAME is null, return the current default.
+   If DOMAINNAME is "", reset to the default of "messages".  */
+extern char *textdomain (const char *__domainname) __THROW;
+
+/* Specify that the DOMAINNAME message catalog will be found
+   in DIRNAME rather than in the system locale data base.  */
+extern char *bindtextdomain (const char *__domainname,
+			     const char *__dirname) __THROW;
+
+/* Specify the character encoding in which the messages from the
+   DOMAINNAME message catalog will be returned.  */
+extern char *bind_textdomain_codeset (const char *__domainname,
+				      const char *__codeset) __THROW;
+
+
+/* Optimized version of the function above.  */
+#if defined __OPTIMIZE__ && !defined __cplusplus
+
+/* We need NULL for `gettext'.  */
+# define __need_NULL
+# include <stddef.h>
+
+/* We need LC_MESSAGES for `dgettext'.  */
+# include <locale.h>
+
+/* These must be macros.  Inlined functions are useless because the
+   `__builtin_constant_p' predicate in dcgettext would always return
+   false.  */
+
+# define gettext(msgid) dgettext (NULL, msgid)
+
+# define dgettext(domainname, msgid) \
+  dcgettext (domainname, msgid, LC_MESSAGES)
+
+# define ngettext(msgid1, msgid2, n) dngettext (NULL, msgid1, msgid2, n)
+
+# define dngettext(domainname, msgid1, msgid2, n) \
+  dcngettext (domainname, msgid1, msgid2, n, LC_MESSAGES)
+
+#endif	/* Optimizing.  */
+
+__END_DECLS
+
+#ifdef _LIBC
+# define _(x) gettext(x)
+# define N_(x) x
+#endif
+
+#endif /* libintl.h */
+
--- a/parser/parser.h
+++ b/parser/parser.h
@@ -27,7 +27,7 @@
 #include <string.h>
 #include <sys/resource.h>
 
-#include <libintl.h>
+#include <sys/libintl.h>
 #define _(s) gettext(s)
 
 #include <sys/apparmor.h>
--- /dev/null
+++ b/libraries/libapparmor/src/intl.c
@@ -0,0 +1,155 @@
+/* Copyright (C) 2003     Manuel Novoa III
+ * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+/*
+ *  Stub version of libintl.
+ *
+ *  Aug 30, 2003
+ *  Add some hidden names to support locale-enabled libstd++.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#undef __OPTIMIZE__
+#include <sys/libintl.h>
+
+/**********************************************************************/
+//#ifdef L_gettext
+
+char *gettext(const char *msgid)
+{
+	return (char *) msgid;
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L_dgettext
+
+char *dgettext(const char *domainname,
+				 const char *msgid)
+{
+	return (char *) msgid;
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L_dcgettext
+
+char *dcgettext(const char *domainname,
+				  const char *msgid, int category)
+{
+	return (char *) msgid;
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L_ngettext
+
+char *ngettext(const char *msgid1, const char *msgid2,
+			   unsigned long int n)
+{
+	return (char *) ((n == 1) ? msgid1 : msgid2);
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L_dngettext
+
+char *dngettext(const char *domainname, const char *msgid1,
+				const char *msgid2, unsigned long int n)
+{
+	return (char *) ((n == 1) ? msgid1 : msgid2);
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L_dcngettext
+
+char *dcngettext(const char *domainname, const char *msgid1,
+				 const char *msgid2, unsigned long int n,
+				 int category)
+{
+	return (char *) ((n == 1) ? msgid1 : msgid2);
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L_textdomain
+
+char *textdomain(const char *domainname)
+{
+	static const char default_str[] = "messages";
+
+	if (domainname && *domainname && strcmp(domainname, default_str)) {
+		errno = -EINVAL;
+		return NULL;
+	}
+	return (char *) default_str;
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L_bindtextdomain
+
+char *bindtextdomain(const char *domainname, const char *dirname)
+{
+	static const char dir[] = "/";
+
+	if (!domainname || !*domainname
+		|| (dirname
+#if 1
+			&& ((dirname[0] != '/') || dirname[1])
+#else
+			&& strcmp(dirname, dir)
+#endif
+			)
+		) {
+		errno = -EINVAL;
+		return NULL;
+	}
+
+	return (char *) dir;
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L_bind_textdomain_codeset
+
+/* Specify the character encoding in which the messages from the
+   DOMAINNAME message catalog will be returned.  */
+char *bind_textdomain_codeset(const char *domainname, const char *codeset)
+{
+	if (!domainname || !*domainname || codeset) {
+		errno = -EINVAL;
+	}
+	return NULL;
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L__nl_expand_alias
+
+/* glibc-ism */
+
+const char *_nl_expand_alias(const char * name);
+const char *_nl_expand_alias(const char * name)
+{
+	return NULL;		 /* uClibc does not support locale aliases. */
+}
+
+//#endif
+/**********************************************************************/
+//#ifdef L__nl_msg_cat_cntr
+
+/* glibc-ism */
+
+int _nl_msg_cat_cntr = 0;
+
+//#endif
+/**********************************************************************/
+
--- a/parser/parser_yacc.y
+++ b/parser/parser_yacc.y
@@ -57,6 +57,12 @@
 #define CAP_MAC_OVERRIDE     32
 #endif
 
+#ifndef RLIMIT_RTTIME
+#define RLIMIT_RTTIME	15
+#endif
+
+
+
 #define CIDR_32 htonl(0xffffffff)
 #define CIDR_24 htonl(0xffffff00)
 #define CIDR_16 htonl(0xffff0000)
@@ -82,6 +88,7 @@ void add_local_entry(Profile *prof);
 
 %}
 
+
 %token TOK_ID
 %token TOK_CONDID
 %token TOK_CONDLISTID
--- a/parser/Makefile
+++ b/parser/Makefile
@@ -86,7 +86,8 @@ OBJECTS = $(patsubst %.cc, %.o, $(SRCS:.
 AAREDIR= libapparmor_re
 AAREOBJECT = ${AAREDIR}/libapparmor_re.a
 AAREOBJECTS = $(AAREOBJECT)
-AARE_LDFLAGS = -static-libgcc -static-libstdc++ -L.
+#AARE_LDFLAGS = -static-libstdc++ -static-libgcc -L.
+AARE_LDFLAGS = -L.
 AALIB = -Wl,-Bstatic -lapparmor -Wl,-Bdynamic -lpthread
 
 ifdef USE_SYSTEM
@@ -161,7 +162,8 @@ htmlmanpages:	$(HTMLMANPAGES)
 
 pdf:	techdoc.pdf
 
-docs:	manpages htmlmanpages pdf
+docs:
+#manpages htmlmanpages pdf
 
 indep: docs
 	$(Q)$(MAKE) -C po all
@@ -332,6 +334,7 @@ install-debian:
 
 .PHONY: install-unknown
 install-unknown:
+	@echo "install inknown"
 
 INSTALLDEPS=arch
 
@@ -376,7 +379,7 @@ install-indep:
 	install -m 755 -d $(APPARMOR_BIN_PREFIX)
 	install -m 755 rc.apparmor.functions $(APPARMOR_BIN_PREFIX)
 	$(MAKE) -C po install NAME=${NAME} DESTDIR=${DESTDIR}
-	$(MAKE) install_manpages DESTDIR=${DESTDIR}
+#	$(MAKE) install_manpages DESTDIR=${DESTDIR}
 
 ifndef VERBOSE
 .SILENT: clean
