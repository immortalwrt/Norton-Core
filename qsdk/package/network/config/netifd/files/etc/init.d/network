#!/bin/sh /etc/rc.common

START=20
STOP=90

USE_PROCD=1

check_ip_ranges() {
	[ -e "/usr/sbin/configure_lan_ip" ] && /usr/sbin/configure_lan_ip reconfigure
	[ -e "/usr/sbin/configure_guest_ip" ] && /usr/sbin/configure_guest_ip reconfigure
}

NFQUEUE_CHAIN_NAME=ROVER_NFQUEUE_CHECK
setup_nfqueue_bypass() {
	[ -z "$(iptables -L $NFQUEUE_CHAIN_NAME 1 | awk '/^DROP/')" ] && iptables -I $NFQUEUE_CHAIN_NAME -j DROP
}
remove_nfqueue_bypass() {
	[ ! -z "$(iptables -L $NFQUEUE_CHAIN_NAME 1 | awk '/^DROP/')" ] && iptables -D $NFQUEUE_CHAIN_NAME 1
}

drain_nfqueue() {
	# Bypass drop anything right before it would be placed in NFQUEUE.
	# This will allow us to drain the queue properly, allowing proper cleanup
	setup_nfqueue_bypass

	local def=5
	local count=${1:-$def}
	while [ $count != 0 ] ; do
		eval "$(awk '{len+=$3;lines++;} END {print "len="len, "lines="lines}' /proc/net/netfilter/nfnetlink_queue)"
		if [ $len = 0 ]; then
			break;
		fi

		sleep 1
		let count=count-1
		echo "Wait $count sec while $lines nfqueue empty: $len"
	done
}

init_switch() {
	setup_switch() { return 0; }

	include /lib/network
	setup_switch
}

network_cleanup() {
	killall netifd 2&> /dev/null
}

start_service() {
	check_ip_ranges
	init_switch

	[ -e "usr/sbin/fst.sh" ] && /usr/sbin/fst.sh configure

	procd_open_instance
	procd_set_param command /sbin/netifd
	#procd_set_param limits core="unlimited"
	procd_set_param respawn
	procd_set_param watch network.interface
	[ -e /proc/sys/kernel/core_pattern ] && {
		procd_set_param limits core="unlimited"
		if [ -e /opt/symantec/rover/bin/core_dump_handler.sh ]; then
			echo "|/opt/symantec/rover/bin/core_dump_handler.sh %s %e %p %t" > /proc/sys/kernel/core_pattern
		else
			echo '/tmp/%e.%p.%s.%t.core' > /proc/sys/kernel/core_pattern
		fi
	}
	procd_close_instance
	[ -f /usr/bin/lte-cm ] && {
		/usr/bin/lte-cm start
	}
	if [ -e /usr/sbin/set_wifi_pwr.sh ]; then
		/usr/sbin/set_wifi_pwr.sh
	fi
	uci set wireless.wifi0.macaddr=$(/usr/sbin/fw_printenv -n wifi0addr)
	uci set wireless.wifi1.macaddr=$(/usr/sbin/fw_printenv -n wifi1addr)
	uci commit wireless
}

reload_service() {
	init_switch
	ubus call network reload
	/sbin/wifi reload_legacy
}

stop() {
	/sbin/wifi down
	[ -f /usr/bin/lte-cm ] && {
		/usr/bin/lte-cm stop
	}
	procd_kill network ''
	network_cleanup
}

service_running() {
	ubus -t 30 wait_for network.interface
	/sbin/wifi reload_legacy
}

validate_atm_bridge_section()
{
	uci_validate_section network "atm-bridge" "${1}" \
		'unit:uinteger:0' \
		'vci:range(32, 65535):35' \
		'vpi:range(0, 255):8' \
		'atmdev:uinteger:0' \
		'encaps:or("llc", "vc"):llc' \
		'payload:or("bridged", "routed"):bridged'
}

validate_route_section()
{
	uci_validate_section network route "${1}" \
		'interface:string' \
		'target:cidr4' \
		'netmask:netmask4' \
		'gateway:ip4addr' \
		'metric:uinteger' \
		'mtu:uinteger' \
		'table:or(range(0,65535),string)'
}

validate_route6_section()
{
	uci_validate_section network route6 "${1}" \
		'interface:string' \
		'target:cidr6' \
		'gateway:ip6addr' \
		'metric:uinteger' \
		'mtu:uinteger' \
		'table:or(range(0,65535),string)'
}

validate_rule_section()
{
	uci_validate_section network rule "${1}" \
		'in:string' \
		'out:string' \
		'src:cidr4' \
		'dest:cidr4' \
		'tos:range(0,31)' \
		'mark:string' \
		'invert:bool' \
		'lookup:or(range(0,65535),string)' \
		'goto:range(0,65535)' \
		'action:or("prohibit", "unreachable", "blackhole", "throw")'
}

validate_rule6_section()
{
	uci_validate_section network rule6 "${1}" \
		'in:string' \
		'out:string' \
		'src:cidr6' \
		'dest:cidr6' \
		'tos:range(0,31)' \
		'mark:string' \
		'invert:bool' \
		'lookup:or(range(0,65535),string)' \
		'goto:range(0,65535)' \
		'action:or("prohibit", "unreachable", "blackhole", "throw")'
}

validate_switch_section()
{
	uci_validate_section network switch "${1}" \
		'name:string' \
		'enable:bool' \
		'enable_vlan:bool' \
		'reset:bool'
}

validate_switch_vlan()
{
	uci_validate_section network switch_vlan "${1}" \
		'device:string' \
		'vlan:uinteger' \
		'ports:list(ports)'
}

service_triggers()
{
	procd_add_reload_trigger network wireless

	procd_open_validate
	validate_atm_bridge_section
	validate_route_section
	validate_route6_section
	validate_rule_section
	validate_rule6_section
	validate_switch_section
	validate_switch_vlan
	procd_close_validate
}

restart() {
	. /usr/sbin/rover_states.sh
	publish_network_restart_state on  # Set network restart state

	drain_nfqueue 5
	ifdown -a
	sleep 1
	trap '' TERM
	stop "$@"
	network_cleanup
	start "$@"
	#  0 will be written to the in_network_restart in qcawifi.sh.
	# We want to do this after all the wireless interfaces are up.

	# now remove the nfqueue bypass
	remove_nfqueue_bypass
	
	# We need to restart qos, so let's use an explicit trigger for this.
	touch /tmp/qos_restart
}

shutdown() {
	ifdown -a
	sleep 1

	stop
	network_cleanup
}
